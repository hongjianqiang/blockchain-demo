WEBVTT

1
00:00:01.760 --> 00:00:04.200
这是一个区块链演示

2
00:00:04.200 --> 00:00:07.379
我们会以非常直观的方式做到这一点

3
00:00:07.379 --> 00:00:07.379


4
00:00:07.379 --> 00:00:07.379


5
00:00:07.379 --> 00:00:09.480
做到让它很容易理解

6
00:00:09.480 --> 00:00:12.480
通过一步一步以可视化的方式来演示区块链的每个关键部分

7
00:00:12.480 --> 00:00:15.630
来理解区块链是什么

8
00:00:15.630 --> 00:00:17.220
开始之前，我们需要先

9
00:00:17.220 --> 00:00:21.990
看看这个我们称之为SHA256（哈希256）的东西

10
00:00:21.990 --> 00:00:21.990


11
00:00:21.990 --> 00:00:25.980
OK. 这里就是其中一个哈希值（也可以称之为散列）

12
00:00:25.980 --> 00:00:25.980


13
00:00:25.980 --> 00:00:27.869
哈希值看起来就像一串随机数字

14
00:00:27.869 --> 00:00:33.870
本质上是一些数据的一个指纹（由64个字符组成）

15
00:00:33.870 --> 00:00:33.870


16
00:00:33.870 --> 00:00:37.469
这里的数据为空，那么它的哈希值恰好就是这个

17
00:00:37.469 --> 00:00:37.469


18
00:00:37.469 --> 00:00:40.920
所以如果我在盒子里输入我的名字“Anders”

19
00:00:40.920 --> 00:00:44.070
你看到哈希值也改变了

20
00:00:44.070 --> 00:00:46.200
事实上我每次改变输入一个字母

21
00:00:46.200 --> 00:00:49.350
HASH都跟着改变

22
00:00:49.350 --> 00:00:52.230
现在退回去，输入anders， OK

23
00:00:52.230 --> 00:00:55.170
这是名字anders的哈希值(HASH，也可以叫散列)

24
00:00:55.170 --> 00:00:57.660
都以19ea开头的小写字母

25
00:00:57.660 --> 00:00:58.590
对

26
00:00:58.590 --> 00:01:01.469
OK，我删除再来一遍

27
00:01:01.469 --> 00:01:08.189
再次键入anders，你就可以看到以19ea开头的完全相同的散列(HASH)

28
00:01:08.189 --> 00:01:08.189


29
00:01:08.189 --> 00:01:10.200
从这个意义上说，它就是这段数据的数字指纹

30
00:01:10.200 --> 00:01:13.740
而无论每次你输入的数据是什么

31
00:01:13.740 --> 00:01:18.150
只要输入完全相同的数据你就得到一个完全一样的散列HASH

32
00:01:18.150 --> 00:01:18.150


33
00:01:18.150 --> 00:01:19.890
我可以键入任何想输入的内容，哪怕是空白什么都没有都可以

34
00:01:19.890 --> 00:01:25.619
像这样空白没内容的散列(HASH)的开头是e3b0xxx

35
00:01:25.619 --> 00:01:25.619


36
00:01:25.619 --> 00:01:28.020
也可以输入成吨的的东西

37
00:01:28.020 --> 00:01:31.890
事实上，你甚至可以输入比如国会图书馆的所有东西

38
00:01:31.890 --> 00:01:31.890


39
00:01:31.890 --> 00:01:34.079
然后你会得到一个哈希值. 有意思的是

40
00:01:34.079 --> 00:01:40.890
无论你输入很少信息，甚至没有信息，或是整个国会图书馆的信息

41
00:01:40.890 --> 00:01:40.890


42
00:01:40.890 --> 00:01:40.890


43
00:01:40.890 --> 00:01:45.149
你总是会得到一串含有64个字符的哈希值

44
00:01:45.149 --> 00:01:45.149


45
00:01:45.149 --> 00:01:49.799
此外，你不可能事先猜到散列对应的内容是什么

46
00:01:49.799 --> 00:01:49.799


47
00:01:49.799 --> 00:01:52.170
你不可能根据这个哈希值推断出对应的国会图书馆的内容

48
00:01:52.170 --> 00:01:54.600
你只能由国会图书馆的内容得到这个哈希值

49
00:01:54.600 --> 00:01:58.409
只要输入的内容是一样的，你将会永远得到完全一样的HASH散列

50
00:01:58.409 --> 00:02:04.860
无论你输入多少次完全相同的信息

51
00:02:04.860 --> 00:02:04.860


52
00:02:04.860 --> 00:02:10.229
我现在要做的是把HASH的这个想法

53
00:02:10.229 --> 00:02:14.920
扩展成我们叫做Block块的东西

54
00:02:14.920 --> 00:02:14.920


55
00:02:14.920 --> 00:02:14.920


56
00:02:14.920 --> 00:02:16.420
让我们来看看一个块(Block)

57
00:02:16.420 --> 00:02:21.220
这就是一个块，它与HASH看起来完全一样

58
00:02:21.220 --> 00:02:25.990
只是数据部分包含三部分

59
00:02:25.990 --> 00:02:25.990


60
00:02:25.990 --> 00:02:31.660
第一部分叫Block, 其实只是某种编号，这是区块1

61
00:02:31.660 --> 00:02:31.660


62
00:02:31.660 --> 00:02:34.030
第二部分叫Nonce, 这是一个随机数

63
00:02:34.030 --> 00:02:35.830
待会我们会探讨随机数是什么，有什么用途

64
00:02:35.830 --> 00:02:37.720
第三部分叫Data, 是附加更多的自定义数据

65
00:02:37.720 --> 00:02:40.420
与我们之前看到的样子非常相似

66
00:02:40.420 --> 00:02:44.380
然而这(个块BLOCK)的散列(HASH)

67
00:02:44.380 --> 00:02:47.290
包含这里三部分(Block、Nonce、Data)的信息

68
00:02:47.290 --> 00:02:50.470
在这里，它却以四个零开头

69
00:02:50.470 --> 00:02:54.130
这是一个相对罕见的散列值

70
00:02:57.880 --> 00:02:57.880
因为大部分数据的散列值都不是以这样四个零开头的

71
00:02:57.880 --> 00:02:57.880


72
00:02:57.880 --> 00:03:01.000
但是这个块(包含Block、Nonce、Data)恰巧是

73
00:03:01.000 --> 00:03:04.900
因为它完全是随机的, 我们就说这个块是有效的

74
00:03:04.900 --> 00:03:04.900


75
00:03:04.900 --> 00:03:08.680
OK，那么如果我要改变这里的任何一条信息

76
00:03:08.680 --> 00:03:11.230
会发生什么呢？

77
00:03:11.230 --> 00:03:13.120
如果我在这里输入些东西

78
00:03:13.120 --> 00:03:16.630
哈希值也将会随之改变

79
00:03:16.630 --> 00:03:18.400
如果我输入字母的话

80
00:03:18.400 --> 00:03:20.260
这个HASH散列以0000开头的机会会是多少?

81
00:03:20.260 --> 00:03:23.050
可能性比较低，但也不是不可能

82
00:03:23.050 --> 00:03:25.840
让我们看看这么做的话会发生什么

83
00:03:25.840 --> 00:03:28.959
我只是想打个hi

84
00:03:28.959 --> 00:03:31.600
看看这个哈希没有

85
00:03:31.600 --> 00:03:36.400
起始不是四个零，所以大框框背景变成了红色

86
00:03:36.400 --> 00:03:36.400


87
00:03:36.400 --> 00:03:38.950
所以现在你知道

88
00:03:38.950 --> 00:03:46.120
这个含有这个信息的区块不是有效的

89
00:03:46.120 --> 00:03:46.120


90
00:03:46.120 --> 00:03:48.220
这就是Nonce随机出现这里的原因

91
00:03:48.220 --> 00:03:54.130
Nonce（随机数）你可以设置的一个数字

92
00:03:54.130 --> 00:03:54.130


93
00:03:54.130 --> 00:03:57.190
使得这个散列再次以四个零开头

94
00:03:57.190 --> 00:03:58.630
那么我们该怎么做呢

95
00:03:58.630 --> 00:04:00.970
现在从1开始

96
00:04:00.970 --> 00:04:03.940
不行，试试2，还不行

97
00:04:03.940 --> 00:04:08.530
再试试3 4 5 6，你知道怎么做了吧？

98
00:04:08.530 --> 00:04:08.530


99
00:04:08.530 --> 00:04:09.700
像我这样坐在这里

100
00:04:09.700 --> 00:04:12.070
从0开始

101
00:04:12.070 --> 00:04:15.100
整天输入这些数字

102
00:04:15.100 --> 00:04:20.048
并试图找出一个实际上能够以四个0开头的哈希值

103
00:04:20.048 --> 00:04:20.048


104
00:04:20.048 --> 00:04:22.900
这要花很长时间

105
00:04:22.900 --> 00:04:25.000
在这里，我做了一个小小的挖矿(MINE)按钮

106
00:04:25.000 --> 00:04:26.230
我相信你一直在想

107
00:04:26.230 --> 00:04:29.050
如果我按下会发生什么

108
00:04:29.050 --> 00:04:30.670
当我按下这个挖矿(Mine)按钮时

109
00:04:30.670 --> 00:04:36.550
他就会遍历从1开始到无穷大的所有数字

110
00:04:36.550 --> 00:04:36.550


111
00:04:36.550 --> 00:04:38.950
直到找到一个以四个0开头的哈希值

112
00:04:38.950 --> 00:04:41.050
这个过程被称为挖矿

113
00:04:41.050 --> 00:04:43.060
让我们现在就按下这个挖坑按钮吧

114
00:04:43.060 --> 00:04:45.460
现在它正在检查所有的数字

115
00:04:45.460 --> 00:04:48.280
从1开始，2 3 4...一路向上尝试

116
00:04:48.280 --> 00:04:52.840
现在它停在59396这个数字

117
00:04:52.840 --> 00:04:55.870
把这三部分（Block、Nonce、Data）内容输入SHA256函数中（其中Nonce为59396）

118
00:04:55.870 --> 00:04:58.060
正好输出一个以四个零开头的哈希值

119
00:04:58.060 --> 00:05:01.060
这符合我对有效区块的定义（就是散列值必须以0000开头）

120
00:05:01.060 --> 00:05:03.940
所以这是一个有效的区块

121
00:05:03.940 --> 00:05:07.480
那现在可以告诉我什么是区块链了吗?

122
00:05:07.480 --> 00:05:11.770
区块链其实就是把这些区块，一个接一个连起来

123
00:05:11.770 --> 00:05:13.600
怎么把他们放在一起呢？

124
00:05:13.600 --> 00:05:16.660
现在让我们做起来

125
00:05:16.660 --> 00:05:16.660


126
00:05:16.660 --> 00:05:19.180
好吧，这是我的区块链

127
00:05:19.180 --> 00:05:21.220
这个是区块1，在比特币中也叫创世区块

128
00:05:21.220 --> 00:05:23.020
像前面区块的数据结构一样，都有一个随机数

129
00:05:23.020 --> 00:05:24.850
也有些数据区

130
00:05:24.850 --> 00:05:27.700
因为是第1个区块，所以前一个区块(Prev)的Hash设为一堆0

131
00:05:27.700 --> 00:05:29.830
让我们往下滚动

132
00:05:29.830 --> 00:05:33.550
这是区块2， 区块3，和区块4

133
00:05:33.550 --> 00:05:36.580
这个区块链有五个区块

134
00:05:36.580 --> 00:05:42.070
区块5的上一个散列值，以0000ae8开头

135
00:05:42.070 --> 00:05:42.070


136
00:05:42.070 --> 00:05:47.979
0000ae8这个的上一个区块3是以0000b90开头

137
00:05:47.979 --> 00:05:52.060
所以你可以发现

138
00:05:52.060 --> 00:05:55.000
每一个区块指向它前面的一个相邻区块

139
00:05:55.000 --> 00:05:55.780


140
00:05:55.780 --> 00:05:59.290
你记得那个这里的第一区块吗？

141
00:05:59.290 --> 00:05:59.290


142
00:05:59.290 --> 00:06:00.729
实际上它没有前一个

143
00:06:00.729 --> 00:06:02.410
所以这里填一堆数字零

144
00:06:02.410 --> 00:06:03.790
实际上它只是一个伪造的数字

145
00:06:03.790 --> 00:06:09.100
好吧，就像我们之前做的那样

146
00:06:09.100 --> 00:06:11.890
如果我改变了一些信息

147
00:06:11.890 --> 00:06:14.979
这个区块的哈希值也将会改变

148
00:06:14.979 --> 00:06:16.210
会使它失效

149
00:06:16.210 --> 00:06:18.340
让我们尝试一下

150
00:06:18.340 --> 00:06:20.440
所以我打算再次输入hi

151
00:06:20.440 --> 00:06:23.050
足可以让这个区块变无效

152
00:06:23.050 --> 00:06:25.630
正如我们假设的那样

153
00:06:25.630 --> 00:06:27.790
如何我要让它有效会发生什么？

154
00:06:27.790 --> 00:06:29.650
现在回去做一些工作

155
00:06:29.650 --> 00:06:31.930
如果我改变了这个区块里的一些东西

156
00:06:31.930 --> 00:06:36.169
这会发生什么？它的哈希会改变

157
00:06:36.169 --> 00:06:36.169


158
00:06:36.169 --> 00:06:39.259
但是这个哈希被复制到下一个块

159
00:06:39.259 --> 00:06:42.199
区块5的Prev也会跟着发生变更

160
00:06:42.199 --> 00:06:43.460
改变了区块4的数据，后面的区块都会发生变化

161
00:06:43.460 --> 00:06:46.849
让我们尝试这里打入hi

162
00:06:46.849 --> 00:06:50.629
你看发生变化了！

163
00:06:50.629 --> 00:06:53.060
我们试着回到我们想要修改的任何地方

164
00:06:53.060 --> 00:06:55.879
也就是过去的某一个区块上

165
00:06:55.879 --> 00:06:59.659
修改这个区块的数据后

166
00:06:59.659 --> 00:07:01.909
它将打破从那以后的所有区块

167
00:07:01.909 --> 00:07:05.900
它之前的区块仍然还是绿色的，但是这个及之后的是红色的

168
00:07:05.900 --> 00:07:14.120
所以如果我想改变这个区块链中的某些东西

169
00:07:14.120 --> 00:07:14.120


170
00:07:14.120 --> 00:07:16.279
我必须把这个区块及其后面的区块都重新挖矿修改了

171
00:07:16.279 --> 00:07:18.110
在这里，我试着修改区块5

172
00:07:18.110 --> 00:07:21.110
我输入hi，然后我们要重新挖矿

173
00:07:21.110 --> 00:07:23.900
然后选择了一个重新生成的Nonce值，使得散列值为四个0开头

174
00:07:23.900 --> 00:07:27.889
这样，这个区块就变成有效了

175
00:07:27.889 --> 00:07:30.199
也就是说，我们似乎可以改变区块链的数据了

176
00:07:30.199 --> 00:07:32.270
我们做得很好对不？

177
00:07:32.270 --> 00:07:34.339
那么如果我回到过去，修改之前的区块会发生什么？

178
00:07:34.339 --> 00:07:38.749
譬如现在我在这里打破这个链

179
00:07:38.749 --> 00:07:42.649
现在我必须重新对这个区块挖矿

180
00:07:42.649 --> 00:07:45.889
这个块将会重新寻找一个新的Nonce随机数

181
00:07:45.889 --> 00:07:49.250
使这个块变成以四个零开头的散列值（因为这才是有效的区块）

182
00:07:49.250 --> 00:07:50.870
寻找这个随机数，它需要或长或短的一段时间

183
00:07:50.870 --> 00:07:52.399
因为它必须遍历很多次，一个一个数字来试

184
00:07:52.399 --> 00:07:56.149
找到了，这个Nonce值是138107

185
00:07:56.149 --> 00:07:56.149


186
00:07:56.149 --> 00:07:58.639
但是这个区块也要重新寻找Nonce值

187
00:07:58.639 --> 00:08:05.330
因为这个区块指向的上一个Prev值不同了

188
00:08:05.330 --> 00:08:05.330


189
00:08:05.330 --> 00:08:07.279
所以得出的这个区块的散列值是无效的（不是以四个0开头的散列的区块是无效的）

190
00:08:07.279 --> 00:08:09.319
因此我也必须重新对这个块进行挖矿，也就是重新寻找Nonce值

191
00:08:09.319 --> 00:08:12.379
好吧，这需要一些时间

192
00:08:12.379 --> 00:08:13.669
这个有一点点快

193
00:08:13.669 --> 00:08:18.349
然后这个块我也必须重新挖矿

194
00:08:18.349 --> 00:08:18.349


195
00:08:18.349 --> 00:08:21.080
好吧，我在这里想表达的意思其实就是

196
00:08:21.080 --> 00:08:24.860
如果我去改变最后这个区块

197
00:08:24.860 --> 00:08:28.550
那么，我所有要做的工作就是重新挖矿这个区块，也就是重新寻找Nonce值

198
00:08:28.550 --> 00:08:31.639
如何我改变过去时间的区块，譬如这里

199
00:08:31.639 --> 00:08:34.969
我就不得不重新挖矿这个, 

200
00:08:34.969 --> 00:08:37.099
这个, 这个

201
00:08:37.099 --> 00:08:40.698
和这个。所以要寻找更多区块的Nonce随机数

202
00:08:40.698 --> 00:08:43.518
过去的区块越多

203
00:08:43.519 --> 00:08:49.760
要改变起来就越来越难，越来越难

204
00:08:49.760 --> 00:08:49.760


205
00:08:49.760 --> 00:08:52.250
这就是区块链是如何抵制篡改的

206
00:08:52.250 --> 00:09:05.750
也就是防篡改机制

207
00:09:05.750 --> 00:09:05.750


208
00:09:05.750 --> 00:09:05.750


209
00:09:05.750 --> 00:09:08.270
在这里你可以看到我已经改变了hi

210
00:09:08.270 --> 00:09:11.210
并且我也重新挖矿了等等

211
00:09:11.210 --> 00:09:15.260
那么，我是如何知道我的区块链是否被重新挖矿过？

212
00:09:15.260 --> 00:09:17.690
让我们来看看

213
00:09:17.690 --> 00:09:18.830
点击Distributed按钮

214
00:09:18.830 --> 00:09:22.490
现在我们看到了分布式的区块链

215
00:09:22.490 --> 00:09:24.590
分布式区块链, 看起与上一个区块链完全一摸一样

216
00:09:24.590 --> 00:09:28.370
共五个区块

217
00:09:28.370 --> 00:09:30.950
但是这个是Peer A

218
00:09:30.950 --> 00:09:33.770
下面这个是Peer B

219
00:09:33.770 --> 00:09:37.880
它碰巧有一个完全同样的区块链拷贝

220
00:09:37.880 --> 00:09:41.150
实际上还有其他的Peer C，等等

221
00:09:41.150 --> 00:09:41.150


222
00:09:41.150 --> 00:09:41.990
继续下去

223
00:09:41.990 --> 00:09:44.180
互联网上还有很多很多Peers，我们称之为节点

224
00:09:44.180 --> 00:09:45.830
他们都有一个完整的区块链副本

225
00:09:45.830 --> 00:09:49.430
这个例子下

226
00:09:49.430 --> 00:09:53.240
如果我看这个哈希是0000e4b开头

227
00:09:53.240 --> 00:09:57.290
然后如果我滚动到下一个

228
00:09:57.290 --> 00:10:00.860
注意它也是0000e4b开头

229
00:10:00.860 --> 00:10:03.200
如果我直接看最后一个区块是0000e4b开头的

230
00:10:03.200 --> 00:10:05.210
那它们一定是相同的，我马上演示给你们看

231
00:10:05.210 --> 00:10:07.760
在这里

232
00:10:07.760 --> 00:10:10.910
我会再次输入hi

233
00:10:10.910 --> 00:10:14.330
然后我会把这个区块重新挖矿

234
00:10:14.330 --> 00:10:16.100
现在我得到一些新的Nonce随机数

235
00:10:16.100 --> 00:10:19.880
在这里Prev指向上一个区块的散列值

236
00:10:19.880 --> 00:10:23.450
然后挖矿这个块

237
00:10:23.450 --> 00:10:26.210
现在好了，所有的链都是绿色的

238
00:10:26.210 --> 00:10:27.260
他们都是绿色的

239
00:10:27.260 --> 00:10:32.180
然而这条链表明最后的哈希是e4b

240
00:10:32.180 --> 00:10:36.260
最底部的也是e4b

241
00:10:36.260 --> 00:10:39.860
这个中间的节点的区块链，在这里是4cae

242
00:10:39.860 --> 00:10:46.220
所以我知道看这个区块链的最后一个区块哈希就知道不对头

243
00:10:46.220 --> 00:10:46.220


244
00:10:46.220 --> 00:10:48.950
这个区块链，尽管所有的哈希值都以四个零开头

245
00:10:48.950 --> 00:10:54.290
我知道这个区块链不是所有节点Peers都是一样的

246
00:10:54.290 --> 00:10:54.290


247
00:10:54.290 --> 00:10:57.410
我有两个Peer是一样的，另一个Peer是不同的

248
00:10:57.410 --> 00:10:59.600
在这里有一个小小民主表决

249
00:10:59.600 --> 00:11:01.340
这个家伙认为这是e4b

250
00:11:01.340 --> 00:11:03.770
这家伙认为这是4ca

251
00:11:03.770 --> 00:11:07.760
这个认为是e4b

252
00:11:07.760 --> 00:11:11.210
少数服从多数，所以e4b胜利

253
00:11:11.210 --> 00:11:14.930
这就是一个完全分布式节点都拥有一份相同的副本

254
00:11:14.930 --> 00:11:18.140
在许多不同的计算机节点上

255
00:11:18.140 --> 00:11:22.370
他们都能够很快发现所有的区块都是相同的

256
00:11:22.370 --> 00:11:22.370


257
00:11:22.370 --> 00:11:24.560
记住

258
00:11:24.560 --> 00:11:28.190
区块链可以轻易拥有成千上万的区块

259
00:11:28.190 --> 00:11:29.780
而根本不需要检查所有的区块

260
00:11:29.780 --> 00:11:34.220
因为，你只需要看看最近的一个区块的散列值

261
00:11:34.220 --> 00:11:34.220


262
00:11:34.220 --> 00:11:40.820
你就可以发现过去任何东西是否有改变

263
00:11:40.820 --> 00:11:40.820


264
00:11:40.820 --> 00:11:48.380
仅仅看最后链中的一个区块就能看出来

265
00:11:48.380 --> 00:11:48.380


266
00:11:48.380 --> 00:11:52.130
因为它会哈希出一个不以四个零开始的值

267
00:11:52.130 --> 00:11:52.130


268
00:11:52.130 --> 00:11:54.830
与好的链中的哈希值非常不同

269
00:11:54.830 --> 00:11:57.800
所以这就是区块链

270
00:11:57.800 --> 00:12:00.230
区块链全部就这么一回事

271
00:12:00.230 --> 00:12:04.520
没有什么更多的知识了

272
00:12:04.520 --> 00:12:07.880
但是如果数据区(就是Data)没有有意义的数据

273
00:12:07.880 --> 00:12:12.890
区块链也没什么卵用

274
00:12:12.890 --> 00:12:12.890


275
00:12:12.890 --> 00:12:15.050
我输入的都是我名字、hi

276
00:12:15.050 --> 00:12:17.210
都是些无关痛痒的信息

277
00:12:17.210 --> 00:12:20.360
所以我们真正想要的是一个标记(或者说是token)

278
00:12:20.360 --> 00:12:22.850
所以我们来做一个区块链上的标记(也就是token)

279
00:12:22.850 --> 00:12:24.440
看看这个，我这有个token

280
00:12:24.440 --> 00:12:26.660
只是完全任意的

281
00:12:26.660 --> 00:12:28.970
我把这些标记叫做美元

282
00:12:28.970 --> 00:12:31.310
所以我们看到，从Darcy发送25美元到Bingley

283
00:12:31.310 --> 00:12:36.800
有4美元27美分，从Elizabeth发送到Jane

284
00:12:36.800 --> 00:12:36.800


285
00:12:36.800 --> 00:12:41.480
基本上就是所有的这些正在发生的交易

286
00:12:41.480 --> 00:12:41.480


287
00:12:41.480 --> 00:12:45.860
我已经刚刚用这些交易代替了先前的数据区(也就是Data区)

288
00:12:45.860 --> 00:12:45.860


289
00:12:45.860 --> 00:12:48.170
就像我们之前看到的一样，这里有多个区块

290
00:12:48.170 --> 00:12:49.610
这个区块有更多的交易内容...

291
00:12:49.610 --> 00:12:51.440
有多少笔交易不重要

292
00:12:51.440 --> 00:12:53.720
可以有很多或者很少

293
00:12:53.720 --> 00:12:56.990
或者一笔交易都没有

294
00:12:56.990 --> 00:12:59.150
如果我们继续下去，就像我们之前看到的

295
00:12:59.150 --> 00:13:01.520
如果往下看，我们注意到我们都有了

296
00:13:01.520 --> 00:13:03.860
同一区块链的所有其它拷贝copies

297
00:13:03.860 --> 00:13:06.380
所以现在的防篡改重要性就体现出来了

298
00:13:06.380 --> 00:13:09.140
如果我改动了什么

299
00:13:09.140 --> 00:13:12.260
譬如这里，你就会注意到

300
00:13:12.260 --> 00:13:14.720
a7fc等等等等等等

301
00:13:14.720 --> 00:13:17.420
这是别的东西

302
00:13:17.420 --> 00:13:20.209
这是一些与下面这里不同的东西

303
00:13:20.209 --> 00:13:22.310
所以从这个角度说，我们能够及时发现变化就很重要了

304
00:13:22.310 --> 00:13:33.589
如果我要修改过去什么信息的话

305
00:13:33.589 --> 00:13:33.589


306
00:13:33.589 --> 00:13:33.589


307
00:13:33.589 --> 00:13:36.529
尤其是钱，很快就能发现转账发生变化了

308
00:13:36.529 --> 00:13:38.240
这就是使用区块链的全部意义

309
00:13:38.240 --> 00:13:44.180
也就是抵制任何形式的更改与变更的全部意义

310
00:13:44.180 --> 00:13:44.180


311
00:13:44.180 --> 00:13:45.920
你能够知道过去发生过的这些事情

312
00:13:45.920 --> 00:13:49.790
就是使用区块链的背后原因

313
00:13:49.790 --> 00:13:57.050
使用区块链来记住tokens(也可以说是交易转账记录)

314
00:13:57.050 --> 00:13:57.050


315
00:13:57.050 --> 00:14:01.819
现在有一种情况我们在这里是没有指出的

316
00:14:01.819 --> 00:14:06.319
Darcy有一百美元

317
00:14:06.319 --> 00:14:08.839
并且他已经给Bingley美元

318
00:14:08.839 --> 00:14:11.959
我们唯一记录了的是：Darcy给了Bingly 25美元

319
00:14:11.959 --> 00:14:13.939
我们并不记录一个银行客户账户余额

320
00:14:13.939 --> 00:14:15.920
我们只记录了金钱的转账数据

321
00:14:15.920 --> 00:14:20.779
所以这会引起的一个问题就是

322
00:14:20.779 --> 00:14:25.160
“Darcy有25美元吗？”

323
00:14:25.160 --> 00:14:27.350
这就是我们现在这个版本的blockchain碰到一个问题

324
00:14:27.350 --> 00:14:30.050
“我们实际上并不知道Darcy是否有25美元。”

325
00:14:30.050 --> 00:14:34.639
那我们来看下一个版本的区块链数据结构

326
00:14:34.639 --> 00:14:37.399
Coinbase类型的区块

327
00:14:37.399 --> 00:14:39.379
这里是一个Coinbase类型的区块

328
00:14:39.379 --> 00:14:42.110
我们将添加一个Coinbase类型的交易到我们的区块

329
00:14:42.110 --> 00:14:44.269
这与是之前见过的区块非常相似

330
00:14:44.269 --> 00:14:47.329
但我们只是在顶部添加一个Coinbase数据字段

331
00:14:47.329 --> 00:14:47.329


332
00:14:47.329 --> 00:14:51.800
这里要说的就是：我们要凭空创造一百美元

333
00:14:51.800 --> 00:14:51.800


334
00:14:51.800 --> 00:14:55.939
并把它交给Anders，而且这个区块里没有交易

335
00:14:55.939 --> 00:14:55.939


336
00:14:55.939 --> 00:14:59.420
因为这之前没有人有钱（这是个创世区块，也就是区块1）

337
00:14:59.420 --> 00:15:03.589
在这下一个区块中，又有100美元凭空冒出来给Anders

338
00:15:03.589 --> 00:15:03.589


339
00:15:03.589 --> 00:15:05.269
我是一个粉丝，我喜欢所以我收下了这100美元

340
00:15:05.269 --> 00:15:06.889
现在我们有些交易记录了

341
00:15:06.889 --> 00:15:08.629
你可以看到他们所有都来自Anders

342
00:15:08.629 --> 00:15:10.879
他们都来自我这里

343
00:15:10.879 --> 00:15:13.100
因为我是唯一一个在这个时刻有钱的人

344
00:15:13.100 --> 00:15:16.129
所以我送了10美元给Sophie

345
00:15:16.129 --> 00:15:19.129
我有10美元吗？

346
00:15:19.129 --> 00:15:20.809
有的，我可以这样做，是因为

347
00:15:20.809 --> 00:15:23.179
这Coinbase交易凭空给了我100美元

348
00:15:23.179 --> 00:15:25.459
所以我可以发送它

349
00:15:25.459 --> 00:15:27.470
你把所有这些交易都加起来

350
00:15:27.470 --> 00:15:28.130
他们是不会超过100美元的

351
00:15:28.130 --> 00:15:30.470
它遵循着一个基本的货币原则

352
00:15:30.470 --> 00:15:34.010
那就是

353
00:15:34.010 --> 00:15:36.900
你不能创造任意余额的金钱出来

354
00:15:36.900 --> 00:15:38.900
只能是每个区块的Coinbase交易凭空创造的100美元出来

355
00:15:38.900 --> 00:15:43.070
所以现在它的发行是受控的

356
00:15:43.070 --> 00:15:45.320
如果我们看看这个我们创造的区块链

357
00:15:45.320 --> 00:15:49.130
并且我们在时间方向上快进

358
00:15:49.130 --> 00:15:52.370
我们注意到，jackson给Alexa两美元

359
00:15:52.370 --> 00:15:58.310
所以jackson实际上有2美元

360
00:15:58.310 --> 00:15:58.310


361
00:15:58.310 --> 00:16:00.260
我们回塑区块，发现是Emily和Madison给了钱给jackson

362
00:16:00.260 --> 00:16:02.300
我们看到Emily已经得到10美元

363
00:16:02.300 --> 00:16:06.440
从Emily给了jackson的10美元

364
00:16:06.440 --> 00:16:09.530
所以jackson确实有钱

365
00:16:09.530 --> 00:16:12.650
所以我们可以一直倒退回溯

366
00:16:12.650 --> 00:16:13.250
并找到其中的交易记录

367
00:16:13.250 --> 00:16:15.200
这实际上是(区块链设计的)其中一个好处

368
00:16:15.200 --> 00:16:18.170
每个区块都有一个Prev字段，所以很容易找到上一个区块

369
00:16:18.170 --> 00:16:22.520
我们只需要寻找上一个区块的散列值就好

370
00:16:22.520 --> 00:16:22.520


371
00:16:22.520 --> 00:16:24.440
就在这里和这里

372
00:16:24.440 --> 00:16:26.450
一直向后回溯

373
00:16:26.450 --> 00:16:29.270
就可以让我们追踪任何的来源

374
00:16:29.270 --> 00:16:30.950
直到找到Coinbase交易

375
00:16:30.950 --> 00:16:33.590
所以这是一个基本区块链

376
00:16:33.590 --> 00:16:36.800
我们在它上面运行着一个货币交易记录

377
00:16:36.800 --> 00:16:38.990
你知道区块链有很多副本

378
00:16:38.990 --> 00:16:41.090
每个人(节点)都有它的副本

379
00:16:41.090 --> 00:16:44.660
所以如果我们在这个区块改成6美元

380
00:16:44.660 --> 00:16:46.850
那么这个节点的这条区块链就是无效的

381
00:16:46.850 --> 00:16:50.150
因为其他成千上万的节点不同意这条被篡改的区块链

382
00:16:50.150 --> 00:16:52.190
其他节点的区块链都是有效且正确的副本

383
00:16:52.190 --> 00:16:56.090
所以这就能抵制篡改了

384
00:16:56.090 --> 00:16:58.970
这就是区块链的一个货币转账记录的运用

385
00:16:58.970 --> 00:17:04.760
对于记录这些转账交易记录的事情是非常有效的

386
00:17:04.760 --> 00:17:04.760


387
00:17:04.760 --> 00:17:17.119
就发生的事情达成协议

388
00:17:17.119 --> 00:17:17.119


389
00:17:17.119 --> 00:17:17.119


390
00:17:17.119 --> 00:17:19.669
过去发生了就是发生了，不可篡改

391
00:17:19.670 --> 00:17:22.910
历史就是这样

392
00:17:22.910 --> 00:17:26.689
这是一个基本的区块链

393
00:17:26.689 --> 00:17:28.369
在它上面都标记着记录

394
00:17:28.369 --> 00:17:34.040
最后，如果你想继续深入了解

395
00:17:34.040 --> 00:17:37.030
请在该网站上演示和点击这些地方

396
00:17:37.030 --> 00:17:37.030


397
00:17:37.030 --> 00:17:41.650
玩弄它，你会理解得更深刻，更清楚区块链是如何工作的

398
00:17:41.650 --> 00:17:41.650


399
00:17:41.650 --> 00:17:43.930
接下来，我们将进入第二部分

400
00:17:43.930 --> 00:17:46.210
就是关于创建交易的更详细内容

401
00:17:46.210 --> 00:00:00.000


